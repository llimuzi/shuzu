[TOC]

# day01: 软件架构介绍 HTML初识

## 1.软件架构介绍

### 1.1. C / S 结构

```js
C/S
	- 客户端/服务器
	- 用户通过客户端来使用软件
	- 服务器用来处理软件的业务逻辑
	- 例子：
		QQ、360安全卫士、王者荣耀 ...
	- 特点：
		1、需要进行下载安装客户端
		2、软件更新时，客户端也要更新
		3、C/S架构的软件不能跨平台使用
		4、C/S架构的软件，客户端与服务器通信时，
			采用的是私有协议，所以相对安全一些

```

### 1.2 B / S 结构

```js
- 浏览器/服务器
	- B/S架构使用网页作为软件的客户端使用
	- 例子：
		淘宝、京东、12306、知乎、微博 ... ...
	- 特点：
		1.不需要安装，直接通过浏览器访问
		2.软件更新时，客户端不需要更新
		3.B/S架构可以跨平台
		4.B/S架构的软件通信采用的是公共的HTTP协议，
			所以安
           全性较差

```

### 1.3 编码

```js
	- 文本文件在存储到计算机的磁盘中时，都需要将其转换为二进制编码，然后保存
    - 将字符转换为二进制码的过程，我们称为编码
		中国 --> 0101010101101010
	- 将二进制码转换为字符的过程，我们称为解码
		0101010101101010 --> 中国
	- 转换的规则我们称为字符集（charset）
		- 常见的字符集
			ASCII
			ISO-8859-1
			GB2312
			GBK
			UTF-8（Unicode编码）

```

## 2.  HTML网页:

### 2.1 html 简介

> 一个最基本的 html 网页结构

```html
<!DOCTYPE html>
<html>
	<head>
	<!-- 这是 html 的注释  -->
		<title>网页标题</title>
		<meta />
	</head>
	
	<body>
	</body>
</html>

```

### 2.2 转义字符 / 实体

```js
### &;    and 符号开头, 分号结尾, 中间是实体的名字
&nbsp;            // 表示一个空格
&lt;				// 小于 号
&gt;				// 大于 号
&copy;				// 版权符号

```

### 2.3 img 标签

```html
使用img标签，来将外部图片引入到当前页面中
	属性：
		src 图片的路径
		alt 图片的描述，这个描述会在图片无法显示时用来描述图片
			主要用于帮助搜索引擎来识别图片的内容
				如果不写alt属性，搜索引擎无法识别图片，图片将不会被收录
		width:图片的宽度
		height：图片的高度
			- 这两个属性，修改一个，另一个会等比缩放
			- 这两个属性，在pc端页面的开发中一般不会使用

```

### 2.4 a 超链接锚点定位

```js
### 超链接
- 超链接可以让我们从一个网页跳转到 另一个 网页
- 使用 a 标签来创建超链接
- 属性:
	href:
	target:  从什么位置 打开页面
    	_self  默认值, 在当前页面打开链接
        _blank  在新的页面打开链接
        
-----------------------------------------------------
### 超链接的锚点定位
#1. href="#" 回到顶部
// 超链接中将 href 设置为  #, 它的作用是跳转到 当前页面顶部.
<a href="#">回到顶部 </a>

#2. href="#id"  去到指定位置 锚点定位
// 给超链接加一个 #id, 可以跳转到 指定 id 的元素的位置
<a href="#bottom"> 去底部 </a>
<p id= "bottom"> p元素 </p>

```



---

# day02: CSS 选择器, 块和内联元素

> 回顾复习:

> 进制介绍

```js
# 网页
	- 根据w3c的规范，一个网页由三个部分组成：
	1. 结构
        - 结构负责定义整个页面的结构，哪里是标题，哪里是段落 ...
        - 使用HTML来定义网页的结构
			
	2, 表现
        - 网页所有的外在显示的内容都属于表现，比如字体大小、颜色、背景..
        - 使用CSS来定义网页的样式
		
	3. 行为
        - 网页和用户的交互我们称为行为
        - 使用JavaScript来负责网页中的交互
		- 一个设计优良网页，要求结构表现和行为三者分离！
# HTML
	- HTML是超文本标记语音
	- 它负责页面的结构
	- 基本格式：
		<!doctype html> <!-- 文档声明，声明HTML的版本，这个表示网页是H5版本 -->
		<html> <!-- 网页的根(root)标签 ,一个页面中只有一个根标签，网页中的所有内容都写在根标签里-->
		<head> <!-- 网页的头部，用来告诉浏览器如何解析网页 -->
			<meta charset="utf-8"> <!-- 设置当前页面的编码字符集 -->
			<title>网页标题</title> <!-- 网页的标题，搜索引擎会根据内容判断网页的信息 -->
		</head>
		<body> <!-- 网页的主体，网页的所有可见内容都应该写在body里 -->
			<h1>一级标题</h1> 
		</body>
		</html>
	- 基本语法：
		标签：
			成对出现
				<标签名 属性名="属性值" 属性名="属性值">标签体</标签名>
			
			自结束标签
				<标签名 属性名="属性值" 属性名="属性值" />
				<标签名 属性名="属性值" 属性名="属性值">
		注释：
			<!-- HTML注释 -->
			注释中的内容不会再网页中显示，但是会在源码中显示
		实体（转义字符）：
			- 实体用于在网页中表示一些特殊的字符
			- 语法：
				&实体名;
			- 例子：
				&nbsp; 空格
				&lt; 小于
				&gt; 大于
				&copy; 版权符号
		常用标签：
			h1 ~ h6
				- 标题标签
				- 从h1到h6重要性依次递减
				- h1最重要，h6最不重要
				- 一般一个页面中只会有一个h1
				- h4往后一般很少用
			p
				- 段落标签
			br
				- 换行标签
			hr  - 水平线（不用）
			img - 引入外部图片
				- 属性：
					src
						- 外部图片的路径，一般使用相对路径
						- 相对路径，指相对于当前文件所在的位置的路径
						- 例子：
							demo
								- bcd
									- 2.jpg
								- hello
									- 1.html => 1.jpg
									- 1.jpg
								- abc
									- 2.html => ../bcd/2.jpg
					alt
						- 图片的描述，搜索引擎根据alt来识别图片的主要内容
					width
						- 设置图片的宽度
					height
						- 设置图片的高度
			a   - 超链接，可以从一个页面跳转到其他页面
				- 属性：
					href 跳转的目标地址：
							http://xxxx 外部网站
							hello.html  内部页面
							#
							#id         跳转到当前页面的指定位置 
					
					target 打开页面的位置
							_self 默认值，在当前窗口打开
							_blank 在新的窗口打开
```

> 进制介绍

```js
# 进制
	- 我们日常生活中使用的都是十进制
	- 十进制
		- 满十进一
		- 0 1 2 3 4 5 6 7 8 9 10 11 12 。。。 20
		- 十进制中单个数字有10个 0-9
		
	- 二进制
		- 满二进一
		- 0 1 10 11 100 101 110 111
		- 二进制中单个数字有两个 0 和 1
	
	- 八进制
		- 满八进一
		- 0 1 2 3 4 5 6 7 10 11 12 。。。 17 20
	
	- 十六进制
		- 满十六进一
		- 由于十六进制是满十六进一，所以在十六进制设计了几种符号用来表示
			10 11 12 13 14 15 ，a, b, c, d, e, f
		- 0 1 2 3 4 5 6 7 8 9 a b c d e f 10 。。。 19 1a 1b 1c 1d 1e 1f 20
		- 十六进制中，一共有十六个单个数字0 ~ f

```

## 1.1 WebStorm的安装步骤：

```js
	① 找到WebStorm的安装目录，进入到lib
		C:\Program Files\JetBrains\WebStorm 2019.1\lib
		
	② 将破解文件(JetbrainsIdesCrack.jar)放入到lib中	
	
	③ 进入项目的bin目录
		找到这两个文件：
			webstorm.exe.vmoptions
			webstorm64.exe.vmoptions
			在配置文件的最下边，添加如下内容
			-javaagent:C:\Program Files\JetBrains\WebStorm 2019.1\lib\JetbrainsIdesCrack.jar
			
	④ 重启webstorm	

```

## 1.2 CSS 的三种使用方式

```js
1. 第一种方式: 内联样式(行内样式), 可以直接将样式写在标签的style属性中
	- 这种方式直接将样式写在 html标签的内部, 导致结构和表现耦合, 并且样式只会对一个标签中的元素生效, 这种方式在开发时一定不要使用
--------------------------------------------------

2. 第二种方式: (内部样式表),可以将样式编写到head中的 style 的标签里, 将样式编写到 style标签中, 通过选择器选中指定元素, 
    - 可以编写一次样式, 对多个元素同时生效, 可以使样式在页面中重复使用
--------------------------------------------------

3. 第三种方式: (外部样式表), 可以将样式编写到一个外部的 css文件中, 样式写到外部文件时, 需要通过 link 标签在html页面中引入外部css的文件
	- 将样式写在外部的css 文件中, 使结构和表现完全分离,
    使得样式可以在不同的页面中进行复用, 方便后期维护
	并且将样式写在一个公共的文件中, 可以使用到浏览器的缓存机制, 提高用户的访问的速度.

```

## 1.3 CSS 的注释 和语法

```js
#1. css的注释为  /* 里边为 注释内容 */

2. CSS语法
	- 语法:
		选择器   声明块
	- 选择器:
        选择器可以用来选中页面中的指定的元素
       
    - 声明块:
    	声明块时由一个大括号括起来, 它里边包括了一个一个的声明, 声明 是一个一个的键值对结构, 一个样式名, 对应一个样式值, 中间使用 ":" 冒号连接,  最后使用 ";" 分号结尾, 每一个声明都可以为元素设置一个指定的样式.

```



## 1.4 常见选择器

```js
0. 通配符选择器 (层级最低)
	- 作用: 选中页面中的所有的元素
    - 语法:  * {}

1. 元素选择器
	- 作用: 选中页面中指定的所有元素
    - 语法: 标签名 {}
	- 例子:   p{} h1{}  a{}  img{}

2. id 选择器
	- 作用: 通过id属性选中唯一的一个元素
    - 语法: #id 调用
    - 例子: #p1{}  #hello{}
    
3. 选择器分组选择器
	- 作用: 可以同时为多个不同的选择器,设置相同的样式
	- 语法: 选择器1,选择器2,...选择器N{}
	- 例子: #p1, a, h1, #p2{}
    
4. 类选择器
	- 作用: 根据元素的class 属性值, 选中元素
	- 语法:  .className{}   
	- 例子:  .p5 {}
------------------------------------------
5. 交集选择器
	- 作用: 可以同时选中同时符合多个选择器的元素
    - 语法: 
    	选择器1.选择器2 ... 选择器n{}
	例子:
		div.box1 {}
-----------------------------------------
6.后代元素选择器
	- 作用: 选中指定元素的后代元素
    - 语法: 祖先 后代{}
	例子:
		div span {}
-----------------------------------------
7. 子元素选择器:
	- 作用: 选中指定元素的子元素
    - 语法: 父元素 > 子元素
	- 例子:
    	div > span {}
------------------------------------------

8. 兄弟元素选择器
	- 作用: 选中指定元素 后的 一个元素
    - 语法: 兄 + 弟 {}
	例子:
	 p + span {}

9. 全部兄弟选择器:
	- 作用: 选中指定元素 后的 所有兄弟元素
    - 语法:  兄 ~ 弟 {};
	例子:
		div ~ span {}


```

## 1.5 块儿元素 和 内联元素

> 块儿元素 和 内联元素

```js
#1. 行元素 | 内联元素 / 行内元素(inline)
	1. 行内元素只会占用自身大小的位置
    2. 常见的行内元素
    	span  a
    3. 内联元素主要用于选中文字内容, 为文本设置样式

#2. 块儿元素: (block)
	- 块儿元素会独占页面中的一行
	- 常见的块元素:
    	div p ul ol li dl dt dd h1 h2 h3 ...
    - 块儿元素主要用于页面布局

#3. 行内块元素，既有块元素的特点又有行内元素的特点
	- 既可以设置宽高，又不会独占一行
    
-------------------------------------------------------
  - 一般情况下都是 使用块元素 去包含内联元素, 而不使用内联去包含块儿元素
  - 块元素中可以放块儿元素
  - p 元素中不能放 块元素
  - a 标签中不能嵌套 a 标签.
```

---

# day03: 伪类, 伪元素,CSS继承,选择器优先级, 盒模型

> :triangular_flag_on_post::triangular_flag_on_post: ​**回顾复习:**

```js
#1. 列表 (list)
1. 列表可以用来表示一组数据 (有序数据)
   - 无序列表
	<ul>
    	<li></li>
	</ul>
-------------------------------------------
	- 有序列表
		<ol>
			<li></li>
		</ol>
-------------------------------------------
	- 自定义列表
		<dl>
			<dt></dt>
			<dd></dd>
		</dl>
--------------------------------------------

#2. CSS 样式的三种用法
	- CSS负责页面的表现，所谓的表现就是页面的样式
	- CSS翻译过来叫做层叠样式表
	- CSS的编写的位置：

	  1. 内联样式
          - 直接将样式编写到标签的style属性内部
		  <p style='color:red;font-size:30px;'>hello</p>
		  - 特点：
			内联样式直接将样式编写到了标签内部，使样式不能复用，
			不方便我们的维护，开发时不要用
	-----------------------------------------------------------------------	
	 2. 内部样式表 ***
			- 直接将样式编写到head里的style标签中
			<style>
				p{
					color:red;
					font-size:30px;
				}
			</style>
			- 内部样式表将CSS和HTML进一步分离，可以通过选择器同时为多个元素设置样式，
				方便后期的维护，但是内部样式表中的样式只能在当前页面中复用，
				不能跨页面使用，这种方式也不是我们最推荐的方式。
	----------------------------------------------------------------------		
	 3. 外部样式表 *****
			- 将css代码编写到外部的css文件中，然后通过link标签进行引入
			<link rel='stylesheet' href='css文件的路径' type='text/css' >
			- 将样式编写到外部文件中，使html和css完全分离，方便后期的维护，
				使样式可以在不同的页面中复用，并且外部文件可以利用到浏览器的缓存机制，
					提高了用户的访问的速度，增强了用户的体验
----------------------------------------------
#3. CSS 语法
	/**/     这是 CSS的注释
    - 结构:
    	选择器 {
            样式名: 样式值;
            样式名: 样式值;
        }
------------------------------------------------

	- 选择器：
			- 选择器可以用来选中指定的一个或多个元素
			- 常用选择器：
				元素选择器
					- 可以选中页面中指定的所有元素
					- 语法：标签名
					- 例子：p{}  div{}  a{}  h1{}
				
				id选择器
					- 可以选中页面中指定id的一个元素
					- 语法：#id属性值
					- 例子：#box{} #p1{} #hello{}
				
				class选择器
					- 可以根据class属性值选中一组元素
					- 语法：.class属性值
					- 例子：.box{} .p1{} .hello{}
				
				选择器分组（并集选择器）
					- 可以选择多种选择器对应的元素
					- 语法：选择器1,选择器2,...选择器N
					- 例子：div,#box1,.hello{} 
				
				通配选择器
					- 选中页面中的所有元素
					- 语法：*
					- 注意：这玩意性能比较差，少用
				
				交集选择器
					- 选中同时符合多个选择器的元素
					- 语法：选择器1选择器2...选择器N
					- 例子：div.hello{}  
				
				后代元素选择器
					- 选中指定的元素的后代元素
					- 语法：祖先 后代
					- 例子：div span{}
				
				子元素选择器
					- 选中指定元素的子元素
					- 语法：父元素 > 子元素
					- 例子： div > span{}
				
				兄弟元素选择器
					- 选中指定元素的后一个兄弟元素
					- 语法：兄 + 弟
				
				所有兄弟元素选择器
					- 选中指定元素的后边所有的兄弟元素
					- 语法：兄 ~ 弟

```

## 1.1  a 伪类

```js
##1. a 伪类
1. 伪类:
	- 伪类选择器用来表示  某种特殊的状态
	- 伪类使用 ":" 冒号开头
    
2. 超链接的伪类选择器
	a:link {
        没有访问过的超链接状态
        :link 就是一个伪类, 它表示一个普通的链接 ()
    }

    a:visited {
        :visited 访问过的链接
        用于隐私的原因, :visited 伪类只能改变字体颜色
        其他的 都无法改变
    }

    a:hover {
        :hover  表示鼠标移入时的链接状态
    }
    a:active {
        :active  表示鼠标正在点击的状态
    }
------------------------------------------------
##2. a 伪类的顺序
 1. 先爱 后 恨 的顺序 love hate
 :link{}        未访问过的超链接的状态.
 :visited {}    访问过的链接状态
 :hover{}       鼠标移入的状态
 :active{}      正在点击的状态
```

## 1.2 伪元素

```js
#1. 伪元素
	- 伪元素用来表示标签的某个特殊的位置
	- :before  表示元素的最开始
    - :after   表示元素的最后面
   
------------------------------------------
#注意伪类和伪元素的区别
	1. 伪类表示的是  某种特殊的状态
    2. 伪元素表示的是 标签的某个特殊的位置

```

## 1.3  CSS样式的继承

```js
# 继承
  1. 和后代可以继承到祖先的财产一样，后代元素可以继承到祖先元素上设置的样式
  
  2. 通过继承，可以将一些共有的样式统一设置到一个祖先元素上，这样所有的后代元素都可以从祖先元素上继承到这些样式
  
  3. 并不是所有的样式都会被继承：
  	 比如： 背景相关的，边框相关的 ...

```

## 1.4 选择器的优先级

```js
#1.选择器的优先级
   当我们通过不同的选择器, 为同一个元素的同一个样式设置不同的值时, 这时样式之间就发生了冲突, 此时哪个样式生效 由选择器的优先级决定的.
   选择器优先级 高 的优先显示
----------------------------------------------

#2. 选择器的优先级 (权重)
	内联样式	    1000
	id选择器	     100
	类和伪类         10
	元素选择器	     1
	通配符选择器	     0
	继承来的样式	    没有优先级
 -----------------------------------------------
  1. 比较选择器优先级时,需要将多个选择器的优先级进行累加,
    结果较大的优先级高, 优先级越高越优先显示, 但是注意分组选择器的优先级是单独计算的.
  
  2. 如果选择器的优先级一样, 则优先级一样, 则优先使用靠下的样式

  3. 优先级的累加不能跨越数量级 #(即:无论多少类选择器相加也不会超过 id 选择器, 其他选择器 累加一样遵循此规则.)
  
 #4. !important 可以在样式的后边添加一个 !important, 这时该样式将会获得最高的权重, 将会优先于其他所有样式显示. 慎用

```

## 1.5 盒模型

> 每个元素都是一个盒

1. 盒模型

   CSS在对页面进行渲染时，会将页面中的每一个元素都想象为一个矩形的盒子.

   这样我们再对页面进行布局时，只需要将不同的盒子摆放在不同的位置即可完成布局

2. CSS通过控制盒子的一系列的属性，来控制元素的大小和位置

   - 内容区（content）: 
   -  内边距（padding）:
   -  边框 （border）: 边框的设计也会影响盒子的大小
   -  外边距 （margin）:

```js
## width 和 height 并不是 设置整个元素的大小, 它们只是用来设置盒子内容区域(content) 的大小的.
```

### 1.5.1 盒子模型的边框

> 盒模型可以 分别指定盒子四个边框的宽度
>
> 顺序为 上, 右 , 下, 左 的顺序设置边框的宽度.

### 1.5.2 盒模型内边距

>**盒模型的几个部分**

```js
# 内容区（content）
    - 内容区用来存放子元素（文本）
    - 使用width和height来设置内容区
---------------------------------------------------
# 内边距(padding)
    - 内边距是内容区与盒子的距离
    - 有四个方向的padding
    padding-top
    padding-right
    padding-bottom
    padding-left
  # 内边距也会影响盒子的大小
---------------------------------------------------
# 边框(border)
    - border是盒子的边缘，离开border就离开了盒子

1. 盒子的可见框的大小由 内容区、内边距 和 边框共同决定
  //可见框的宽度 = (border-left-width) + (padding-left) + width + (padding-right) + (border-right-width)
  //可见框的高度 = (border-top-width) + (padding-top) + height + (padding-bottom) + (border-bottom-width)

```

### 1.5.3 外边距

:red_circle: 外边距不会影响盒子可见框的大小,只会影响盒子位置

```js
# 外边距 margin
1. 外边距不会影响盒子的可见框的大小, 但是他会影响盒子的位置.
> 同样有四个方向的外边
    - margin-top
    - margin-right
    - margin-bottom
    - margin-left

2. 由于元素默认情况是在网页中是从左向右，自上向下排列, 
   所以默认情况下，设置上和左外边距时，元素自身的位置会发生改变
   而设置右和下外边距时，会挤开别的元素
   
3. 使用margin 可以同时设置四个方向的外边距
```

### 1.5.4 内联元素的 盒模型

:red_circle::red_circle::red_circle: 外边距 margin的  一些补充

```js
1. 如果将 margin的值设置为auto, 则由浏览器自动设置外边距

2. 如果将左或右外边距设置auto，则浏览器会让左或右外边距尽可能大
	margin-left:auto;     左边空白最大,元素会在最右边
	margin-right:auto;    右边空白最大,元素会在最左边,然后挤开其他元素
----------------------------------------------------------
3. 如果左右两个同时设置为auto，则会使左右外边距相等，也就是是元素在其父元素中水平居中
	margin:auto;   // 会将该元素水平 居中
-----------------------------------------------------
4. 垂直方向的外边距设置为 auto, 浏览器会将其设置为 0;
	margin-top:auto;   // 不会起效果
	margin: 0 auto;    // 通常会使用这种方式写.
```

:triangular_flag_on_post::triangular_flag_on_post::triangular_flag_on_post: 内联元素的 盒模型

```js
1. 内联元素不支持设置 宽度 和 高度

2. 内联元素 可以设置 padding, 但是垂直方向的 padding不会影响到布局.(基本没用)

3. 内联元素可以设置 border, 但是垂直方向的 border不会影响到布局.(基本不用)

4. 内联元素可以设置左右方向的 margin, 但是垂直方向的 margin没有作用.

```

### 1.5.5 外边距的重叠

:small_red_triangle::small_red_triangle: 外边距重叠

```js
### 外边距的重叠
## 垂直方向的相邻元素 会发生外边距重叠的现象.

  1. 兄弟元素: (不是问题)
	兄弟元素相邻的垂直方向 外边距会取两个值中的较大值
    
# 2. 父子元素: (是个问题)
	子元素的上外边距会传递给父元素. 
    (即: 子元素设置上外边距向下移动的时候, 会因为外边距重叠, 把父元素也 带下去向下移动). 

## 水平方向的外边距会 进行求和.
```

# day04:

## 1.1: overflow

```js
1. 子元素或文本内容，是存在于父元素的内容区中的，
    如果子元素的大小超过父元素内容区的大小，
    这样会导致子元素从父元素中溢出
    
2. 这时我们就需要通过一个样式，来告诉父元素如何处理溢出的内容
	overflow: 用来设置如何处理溢出的元素
    可选值：
        visible: 默认值 溢出的内容会在元素外显示
        hidden: 溢出的内容会被裁剪，不会显示
        scroll: 生成水平和垂直 双方向滚动条
        auto: 根据需要生成滚动条

```

## 1.2 display 和 visibility

```js
 # display可以用来设置元素的显示的状态
 1. 可选值：
     block 块元素
     inline 行内元素
     inline-block 行内块元素
	  none 不在页面中显示
      
# 行内块元素，既有块元素的特点又有行内元素的特点
	既可以设置宽高，又不会独占一行
------------------------------------------------------
# visibility 可以设置元素的显示的状态
  可选值：
    visible 默认值，元素在页面中显示
    hidden 元素在页面中隐藏，但是依然会占据页面的位置
                       
```

## 1.3. 文档流

>:smile::smile:

```js
#1.文档流:
1. 文档流是网页最下面的一层, 我们所创建的所有元素 默认情况 下都是在文档流中排列的.

2. 元素在文档流中的特点:
   > 块元素
	- 块元素在文档流默认宽度是 "父元素" 的 100% (width:auto)
	- 块元素在文档流中默认高度是被内容撑开 (由子元素决定).
    - 块元素在文档流中是 自上向下垂直排列
   
   > 内联元素
	- 内联元素在文档流中, 宽度和高度都是被内容撑开的.
    - 内联元素在文档流中, 自左向右水平排列. 如果一行满了, 自动换到下一行
	   继续自左向右水平排列. (和我们书写的规则是一样).

```

## 1.4: 浮动

### 1.4.1  浮动作用

```js
浮动 (float)
    > 默认情况下, 块元素在文档流上会自上向下垂直排列, 我们可以通过浮动来使元素脱离文档流, 使他们水平排列
	> 使用 float 来设置元素的浮动
      - 可选值:
      	none, 默认值, 元素不浮动, 在文档流中.
        left, 元素向左浮动
		right: 元素向右浮动
 -----------------------------------------------------
            
    > 当元素开启浮动以后, 元素会 完全脱离文档流,  然后向页面的左侧或右侧浮动, 文档其他元素会自动 占有 它空出来的位置
#   > 浮动元素的位置 不会超过它上面 没有浮动的 块元素.
#   > 浮动元素的位置, 不会超过它 上面 浮动的 兄弟元素.

```

### 1.4.2  浮动的特点

:triangular_flag_on_post::triangular_flag_on_post: ​ ​ **内联元素脱离文档流以后, 会变成块元素**. 和 块元素的特点一样.

```js
#1. 浮动特点
 1. 当元素开启浮动以后, 元素会完全从文档流中脱离, 然后向页面的左侧或右侧浮动, 文档其他元素会自动占有它空出来的位置.
 2. 元素浮动时, 最远也不能超过它的父元素的边框.
 3. 浮动元素的位置不会超过它上面 没有浮动的 块元素.
 
#2. 块元素脱离文档流的特点:
 1. 元素脱离文档流以后, 块元素的宽度和高度默认都会被内容撑开
 2. 脱离文档流以后, 块元素不会再独占页面中的一行.
 
#3. 内联元素脱离文档流的特点
 1. 内联元素脱离文档流以后, 会变成块元素. 和 块元素的特点一样.
 
 	# 元素一旦脱离文档流, 就不用再去区分块和内联了.

```

### 1.4.3 清除浮动影响的方式

1. 方式一: 将父元素的高度写死

2. 开启父元素的 BFC

3.  clear属性清除浮动的影响.

   ```js
   #clear 属性清除浮动的影响
   	- 可选值
   	left: 清除左侧浮动元素的影响.
       right: 清除右侧浮动的影响
       both: 清除影响较大的一侧的 浮动元素的浮动的影响
   ```


## 1.5. 高度塌陷 & BFC

1. 高度塌陷

```js
#1. 高度塌陷
 - 块元素在文档流中, 高度默认情况下是被子元素撑开的.
   如果子元素 设置了浮动, 子元素会完全脱离文档流
   脱离文档流以后, 子元素将无法撑起 父元素的高度, 导致父元素的高度丢失.
   这也是高度塌陷的问题, 父元素的高度塌陷 其他元素会自动上移, 将会导致页面的布局的混乱.
  
```

2.  BFC(Block Formatting Context)  块级格式化环境.

```js
### BFC是元素的一个隐藏属性, 默认情况下 BFC 是关闭的.
#1. 开启 BFC 以后, 元素会有如下特性:
 >1. 开启 BFC以后, 子元素的垂直外边距不会传递给父元素.  
 	(即: 子元素和 父元素 "外边距框重叠" 的问题中, 如果给 子元素设置 margin-top 的 会把父元素 同时带着向下 移动,把 margin-top 的垂直外边距传递给 父元素,开启 BFC之后,就不会再出现这个问题. )
============================================================
     
 >2. 开启 BFC以后, 元素不会被浮动元素所覆盖
	(即: 元素浮动后, 浮动元素下面的元素会 跑上去, 被浮动元素所覆盖, 开启 BFC之后, 不会再出现这种问题.)
 ---------------------------------------------------
	<style>
       #box1 {
            width: 200px;
            height: 200px;
            background-color: red;
            /*  box1 浮动 */
            float: left;
        }
        
        #box2 {
            width: 200px;
            height: 200px;
            background-color: green;
 /* 给未浮动的 box2 开启BFC, box2 依然会在文档流中上去, 但是不会再被 box1 所覆盖 */
            overflow: hidden;
        }
     </style>

	 <div id="box1"></div>
     <div id="box2"></div>

----------------------------------------------------------
 >3. 开启 BFC以后, 父元素可以包含浮动的子元素.
 
************************************************************
### 开启 BFC 的方式
>>. 如何开启 BFC
	1. 设置元素的 绝对定位
    2. 将元素设置为 inline-block
	3. 设置 元素浮动
    4. 将元素的 overflow 设置为一个 非 visible的值,通常设置为 hidden
    
 - 我们一般是通过设置 overflow:hidden 来开启元素的bfc，来解决高度塌陷的问题

```

## 

> 图标字体:  iconfont   通过这个技术, 可以将小图片当成是 一个文字使用.
>
> 1.   <!--    引入iconfont的css-->
>        <link rel="stylesheet" href="ft/css/all.css">
>
> 2.   <!-- 引入图标字体的类样式 -->
>
>    <i class="fas fa-angle-down" style="font-size: 100px; color: greenyellow"></i>

## 1.6:  雪碧图,  精灵图,  CSS精灵

> 1.  HTML页面中没有办法直接存储图片、音频这些多媒体资源，所有这些资源，都是以外部资源的形式引入,  浏览器在加载这些资源时，并不是一次性将所有的资源全部加载,   而是按需加载，浏览器会直到资源第一次被使用时才会去加载资源
> 2.   问题的根源就是，三个图片被分成了三次加载，要解决只需要一次性将三张图片全部加载即可,  我们可以将三个按钮统一保存到一个图片中，这样可以一次加载三个按钮,  这种将多个图片保存到一个图片中技术我们称为CSS Sprite（CSS精灵）
>
> 

```js
##1. 所以这种图我们称其为雪碧图

#1. CSS精灵图优点：
      1.一次性加载多个图片，避免多次加载加快访问速度
      2.将多个图片保存到一个图片中，降低了图片的大小
#2. 缺点：
      1.只适用于背景图片
      2.图片必须是固定大小

#3. 雪碧图的使用：
    1.确定图标的大小
    2.引入图片，将其设置为元素的背景 (背景图片使用)
    3.测量图片的位置，确定偏移量

```

# day05: 定位, 图标字体, 背景图片之精灵图

# day06:  京东网页布局完成

## 1.1 京东网页布局内容



# day07: JS 初识, 标识符, 字面量,变量

## 1.1: form 表单

>  表单:
>         - 表单的作用就是用于提交信息
>                 - 网页中的表单，用于将信息提交给远程的服务器
>             比如：baidu的搜索框、用户的注册的页面 ...

## 1.2:  JS 初识:

1.  JS 的编写的位置

```js
1. 将 JS 编写在超链接的 href 属性中
	格式:  javascript:;      冒号, 和分号中间写 JS 代码
    这些代码会再 点击超链接的时候,执行.
  - 可以使用 javascript:; 作为 超链接的占位符使用.
  
2. 可以 将 JS 代码写在元素的指定属性中:  比如元素的onclick属性里
	<button onclick=: JS 代码 ;></button>

3. 写到 内部的 JS 代码, 是用 script 标签来扩起来, 写在当前的页面内部的JS
4. 也可以将 JS 代码编写到 外部的 JS 文件中, 然后通过 script 标签来引入外部 的 JS 文件.

```

2. 字面量

```js
1. 字面量
	- 字面量就是一个值，它所代表的意思就是它本身
    - 比如：1 2 3 4 'hello' true false null
    - 在js中可以直接使用字面量，但是直接使用字面量非常的不方便

2. 变量
    - 变量可以用来存储字面量，并且变量中可以保存不同的字面量
    - 我们一般都会使用变量来存储字面量，而不直接使用字面量
    - 变量还可以用来描述字面量

```

3. 标识符

```js
1. 标识符，在JS中所有可以自主命名的内容都可以认为是一个标识符
	比如：变量名、函数名、类名
    标识符的规则：
    	1.标识符中可以包含字母、数字、_、$，但是不能以数字开头
        2.标识符不能是js中的关键字和保留字,也不建议使用js中的函数名作为标识符
		3.js中标识符采用驼峰命名法：
         - 小驼峰（主要用它，变量名，函数名）
                - 首字母小写，每一个单词开头的字母大写，其余字母小写
                - maxLength
                - aaaBbbCccDdd
        - 大驼峰（类名）
                - 首字母大写，每一个单词开头的字母大写，其余字母小写
                - MaxLength
                - AaaBbbCccDdd

```

# day08:  数据类型,强制类型转换, 运算符

## 1.1 数据类型

> JS 中的 六种原始的数据类型

```js
String,  Boolean,  Number, Null, Undefined,  Object.

1. String 在 JS 中既可以使用 双引号, 也可以使用 双引号
2. 在 JS 中, 所有的数字类型都属于 Number (包括整数  和 浮点数)
3. typeof 可以用来检查一个值的 类型.  如:
	var str = "你好";
	console.log(typeof str);
```

> JS 中数值类型的注意点

```js
1. JS 中所有的数字都属于Number

2. 在 js 中 和 0 相除不会报错, 而是会返回 infinity

3. NaN 表示一个 非数字 (not a Number);

4. JS 中可以确保大部分的整数运算都可以获得一个精确的结果, 
    但是小数运算有可能得到一个不精确的结果.  
    如果对运算的要求比较高, 不要直接在JS 中直接元素.

```

> 布尔值

```js
布尔值，布尔值主要用于程序中的逻辑判断
    布尔值一共只有两个值：
    true 表示真
    false  表示假
    使用typeof检查 布尔值 会返回 boolean
                
```

> null 和 undefined 

```js
1. null空值，在js中专门用来表示不存在，表示空
     - 使用typeof 检查一个null，他会返回object
 -------------------------------------------------------
2. undefined，表示未定义，声明一个变量但是不为他赋值，此时变量的值就是undefined
    - 使用typeof 检查一个 undefined 他会返回 undefined

```

## 1.2:  强制类型转换

### 1.2.1 其他的数据类型转换为 字符串

```js
###1. 类型转换指将一种数据类型转换为其他的数据类型
  类型转换一般指将其他的类型转换为String、Number、Boolean
  
##1. 将其他的数据类型转换为字符串
#方式一: 通过 String()  函数来将一个 其他类型转化为字符串
    - 原理:
    	当使用 String() 函数将一个数据转换为字符串时:
	  如果被转换的数据, 具有 toString() 方法, 它会直接调用 toString() 转换
      
      被转换的数据为 null 时, 直接返回 'null'
	  被转换为的数据为 undefined 时, 直接返回 'undefined'

	var a = 10;
	a = String(a);  // 10 ---> '10' 转换为字符村 10
----------------------------------------------------------

#方式二: 通过被转换数据的toString() 方法来将其他的类型转换为字符串
		- toString() 方法不能用于 null 和 undefined 的转换.
	
        var a = 100;
		a = a.toString();  // 100 ---> '100' 转换为字符串100

```

### 1.2.2 其他类型转换为 数字

>其他类型转换为数字

```js
###1. 方式一: 
1. 使用 Number() 函数将其他的类型转换为数字
   数字转换的情况
   # 字符串
   - 如果字符串时一个合法的数字,则直接转换为对应的数字.
   - 如果字符串是一个不合法的数字, 则转换为 NaN
   - 如果字符串是一个空串或者一个纯空格的字符串, 则转换为 0

	# 布尔值
     - true 转换为 1
	 - false 转换为  0

    # null 
    	null 转换为 0

	# undefined
    	- undefined 转换为 NaN

###2. 方式二:
	使用 ParseInt()  或 parseFloat() 方法
> 使用者两个方法专门用来对付 字符串,  专门用来将字符串转换为数字
	- parseInt()
	  将字符串转换为整数
      parseInt() 在解析字符串时, 会从左向右获取字符串中所有的有效整数部分		100.5  

	- parseFloat();
	  - 将字符串转换为小数
	  - 他可以提取字符串中有效的小数部分.

```

## 1.3 其他类型转换为 数字

```js
###1. 其他类型转换为布尔值
# 使用 Boolean() 函数
 1. 转换情况
	- 数字:   除了 0 和  NaN, 都是 true
	- 字符串
		- 除了空串都是 true

	- null 和 undefined      都是false
    
    - 对象一般都是 true

	- 所有表示空性的都是   false

```

## 1.4 运算符

```js
###1. 运算符（操作符）
    - 通过操作符可以一个或多个值进行各种的操作（运算）
     1.  算术运算符
         + 加法运算符
         - +可以对符号两侧的值进行加法运算，并将结果返回
         - 字符串的加法：
            - 如果对两个字符串进行加法运算， 会将两个字符串拼接为一个字符串
            - 任何值和字符串进行加法运算， 都会先将其转换为字符串，然后在和字符串拼串
            - 我们再做类型转换时，经常使用为一个值 +""的形式来将其转换为字符串， 它的原理和String()函数是一样的

     2. 减法运算符
     3. * 乘法运算符
	 4. / 除法运算符
	 5. % 取模运算
         - 两个数相除取余数
-------------------------------------------------------------------------------------
   - 除了字符串加法，其余所有的运算，如果是两个不同类型的值之间进行运算，  都会先转换为数字然后在运算
   - 任何值和NaN做运算，结果都是NaN
   - 也可以通过：
       -0 (减0) 或 * 1 或 /1 来将其他类型转换为数字

```

## 1.5 一元运算符

```js
###1. 一元运算符只需要一个操作数
    +
        - 一元的+，正号
        - +不会对数字产生任何影响
    -
        - 一元的-，负号
        - -会对数字进行符号位取反 正变负，负变正

#       - 如果对非Number类型的值进行一元的+ -，会先将其转换为Number，然后再运算.  
	 所以我们可以利用这个特点，来使用一元的 + 来将其他的数据类型转换为Number，
		原理和Number()函数一样的
        
     var a = -10;
	 a = -a;

```

### 1.6 自增自减

```js
++
    - 自增运算符
    - ++可以使一个值立即增加1
    - ++分成前++（++a），和后++（a++）
        - 无论是++a还是a++，都会使变量立即自增1
            - 但是不同的是 ++a 和 a++ 的值不同
                ++a的值是自增以后的值，新值
                a++的值时自增前的值，原值
--------------------------------------------------------
-- 
    - 自减可以使变量在原值的基础减1
    - 自减分成前减减(--a) 和 后减减(a--)
    - 无论是--a还是a--，都会使原变量-1
    - 不同的是，--a和a--的值不同
     a--是变量自减前的值，原值
    --a是变量自减后的值，新值

```

## 1.7 逻辑运算符 (布尔运算)

```js
 逻辑运算符（布尔运算）
     - ！逻辑非
     	- 非运算可以用来对一个布尔值进行取反操作
  			true变false，false变true
        - 如果对一个非布尔值进行非运算，  它会先将其转换为布尔值，(然后再取反)
        所以我们可以利用这一特性，来将一个  非布尔值转换 为布尔值
        只需要对一个值取两次反，即可将其变成布尔值
        原理和Boolean()函数是一样的
---------------------------------------------------------
  - && 逻辑与
   - 与运算可以对符号两侧的值，进行与运算
   - 如果两个值都是true，则结果为true，
		有一个false，最终结果就是false
        （与运算是找false的）

   - || 逻辑或
      - 或运算可以对符号两侧的值，进行或运算
      - 如果两个值中有true，则返回true，
        否则返回false（或运算是找true）

   - 在JS中，与或运算都是短路的与的和短路的或
            与，如果第一个值是false，则不会再看第二个值
            或，如果第一个值是true，则不会看第二个值

```

# day09:  逻辑运算符,相等运算符

## 1.1 逻辑运算符

```js
 非布尔值的逻辑运算
     - 当我们对非布尔值进行与或运算时，
        他会先将其转换为布尔值，然后再运算
        最终会返回原值

     - 与运算：
       - 如果第一个值是false，则直接返回第一个值
		 如果第一个值是true，则返回第二个
         如:   var result = 1 && 2   // 返回 2

     - 或运算：
       - 如果第一个值是true，则直接返回第一个
        如果第一个设置false，则返回第二个


```

## 1.2 关系运算符

```js
###1. 关系运算符：
    - 关系运算符用来检查两个值之间的关系是否成立，
	如果成立返回true， 不成立返回false

    > 检查左侧值是否大于右侧值
    >= 检查左侧值是否大于或等于右侧值
    <  检查左侧值是否小于右侧值
    <= 检查左侧值是否小于或等于右侧值

    - 如果对非数字类型值进行比较（两个字符串除外），它会将这些值
转换为数字然后在比较
	- 任何值和NaN做任何比较，结果都是false

###2.  字符串笔记注意点
	当我们使用>、<、>=、<= 这些运算符对字符串进行大小比较时，
    比较的是字符串中每个字符的Unicode编码的大小,
    比较编码时，是逐位比较，第一位和第一位比，第二位和第二位比
	利用这个特点，可以比较两个字符串的大小，从而对他们按照字母顺序进行排序
    注意如果是两个字符串型的数字比较大小也会比较Unicode编码，这时往往会得到一个我们不想要的结果,  所以比较两个字符串型的数字时，一定一定一定要进行类型转换

```

## 1.3 相等运算符

```js
相等运算符：
    ==
        - 相等运算符，用来比较两个值是否相等
        - 当对两个不同类型的值，进行相等比较时，
          他会将他们转换为相同类型的值然后再比较
          一般情况下都会转换为数字进行比较
    !=
        - 不相等运算符，用来比较两个值是否不相等
        - 它对不同类型的值进行自动的类型转换，
        只有转换后不相等才会返回true
----------------------------------------------------------
    ===
        - 全等

   !==
        - 不全等
        - 这两个运算符和相等和不等类似，不同的是,
        他们不会做自动的类型转换
----------------------------------------------------------
#  NaN 不和任何值相等，包括它自己
# 需要通过 isNaN()  函数来检查一个值是否是NaN

```

# day10: 逻辑元素符, 流程控制语句, continue 和 break

## 1.1 条件运算符

> 条件运算符    --  三元元素符   --    三目运算符

```js
#	? :
1. 语法:
	条件表达式 ? 表达式1 : 表达式2;
---------------------------------------------------------
2. 执行的流程：
	 三元运算符在执行时，会先对条件表达式进行求值判断，
     如果结果为true，则执行表达式1，并返回执行结果
     如果结果为false，则执行表达式2，并返回结果

```

## 1.2 语句

```js
# 语句
	- 语句就是 JS 中的 一个一个的指令
    - 默认情况下, 一行就是一个语句

# 代码块
	- 在 JS 中可以使用大括号来将多个语句括起来, 
        这样就形成了一个代码块, 同一个代码块中的代码, 要么都执行, 要么都不执行.
    - 我们可以使用我们的代码块来为代码分组
	- JS 中的代码块,只具有分组的作用, 没有其他任何作用.  // 即在代码块里定义的变量,在 外部依然可以访问, 默认情况下不会隔离作用域.
    {
        console.log("hello");
        var a = 10;
    }
	console.log(a);  // 打印出  10

```

## 1.3 流程控制语句

```js
1, 代码的执行顺序是自上向下一行一行执行的,  流程控制语句，可以用来改变程序的执行顺序，或者可以让指定的代码反复执行多次。
    
   1. 条件判断语句
   2. 条件分支语句
   3. 循环语句

```

1. **条件判断语句  if 语句** 

>   if语句:    (这里就用到了 代码块 )

```js
if(条件表达式) {
    语句...
}
    
执行流程:
    if语句执行时，会先对if后的条件表达式进行求值判断，
        如果结果为true，则执行if后的语句
        如果结果为false，则不执行

# 注意：
	if语句它只会控制紧随其后的那一条语句，其他语句不会被if所控制
    如果需要控制多条语句，则可以在if后写一个代码块
    
    条件表达式可以是一个非布尔值的表达式，
    如果条件表达式是一个非布尔值，他会将其转换为布尔值然后在判断
```

>  if - else 语句 

> :triangular_flag_on_post::triangular_flag_on_post: ​语法 : 

```js
  if(条件表达式){
      语句...
  }else{
      语句...
  }
      
# 执行流程 
	if-else语句在执行时，会先对if后的条件表达式进行求值判断，
      如果结果为true，则执行if后的代码块，
      如果结果为false，则执行else后的代码块
```

>  if -  else if - else 语句 

> :triangular_flag_on_post::triangular_flag_on_post: ​语法:

```js
     if(条件表达式){
         语句...
     }else if(条件表达式){
         语句...
     }else if(条件表达式){
         语句...
     }else if(条件表达式){
         语句...
     }else{
         语句...
     }
         
# 执行流程
	if-else if-else语句在执行时，会自上向下依次对条件表达式进行求值判断
         如果结果为true，则执行其后的代码块，执行完毕语句结束，
         如果结果为false，则继续向下判断，直到有true为止
         如果所有结果都是false，则执行else后的代码块
         
# 注意:
	if-else if-else的多个代码块中只会有一个会被执行，
    有执行的语句就会立即结束，剩下的条件表达式都不会再进行判断了
```

2. **条件分支语句 (switch...case)**

>:triangular_flag_on_post::triangular_flag_on_post: ​条件 分支​语句 语法

```js
     switch(条件表达式) {
         case 表达式1:
             语句...
             break
         case 表达式2:
             语句...
             break
         default:
             语句...
             break
      }

- 执行流程:
	switch...case语句在执行时，会自上向下将switch后的表达式和case后的表达式进行全等比较，
        如果两个表达式全等，则从当前case处开始向下执行语句，
        
        如果不希望执行其他case后的语句，可以在当前case后添加一个break
        
        break一执行，switch会立即结束
        
        如果两个表达式不全等，则继续向下判断，直到找到全等的为止，
        
        如果所有的表达式都不全等，则从default处开始向下执行代码

```

3. **循环语句** 

>1. while 循环 
>2. for 循环

```js
1. while 循环

	while(条件表达式) {
        语句...
    }

2. 执行流程
	while语句执行时，会先对条件表达式进行求值判断，
       如果为false，则语句立即结束
       如果为true，则执行while后的代码块（循环体），
       执行完毕继续对条件表达式进行求值判断，以此类推
```

```js
1. for 循环
	for循环和while循环功能上是完全重复
    不同的是，for循环将三个表达式统一编写到了一个位置，for循环结构会比较清晰
    
2. 语法:
	 for(①初始化表达式; ②条件表达式; ④更新表达式;){
         ③语句...
     }
         
3. 执行流程
	for循环执行时，
    ① 先执行初始化表达式，初始化一个变量
    ② 然后执行条件表达式进行求值判断
        如果是false，循环结束
        如果是true，继续向下
    ③ 条件表达式结果为true，则执行循环体
    ④ 循环体执行完毕，然后执行更新表达式，对变量进行更新
    ⑤ 重复②
    
    
    注意：
    for循环中有三个表达式，这三个表达式都可以省略不写

```

## 1.4 continue 和 break

```js
###1. break
    - break关键字可以用来立即结束switch语句和循环语句
    - break会立即终止离他最近的 那个循环,  不再循环.


###2. continue	
	  - continue关键字只能作用于循环
      - continue 可以用来跳过当次循环（离他最近的循环）, 直接进入下一次循环.

```

# day11: 对象,  函数,  作用域

## 1.1  对象的分类

> 数据类型
>
> 1. 原始数据类型
>
>    String, boolean, number, null  undefined
>
> 2.  引用数据类型 Object (对象)

```js
1. 内建对象
	- 由ES标准所定义的对象，所有对ES标准的实现中都可以使用这些对象
    - 例子：String Number Math RegExp ...
    
2. 宿主对象
    - 由JS的运行环境所提供的对象，目前来讲就是浏览器提供的对象
    - 比如 DOM和BOM
    	console document window ...
        
3. 自定义对象
	- 由我们自己定义的一些对象...
   
>> 对象
	 对象是一种复合的数据类型，在对象中可以添加各种的属性，
     而这些属性就相当于一个变量，也就是说对象中可以存储其他的变量
     对象就相当于是一个存储变量的容器！

```

## 1.2 创建对象的 3 种方式

> 1.  调用系统的构造函数创建对象  var obj = new Object()
> 2.  字面量的方式创建对象    var obj = { }
>     3.  自定义构造函数创建对象		

### 1.2.1 调用系统的构造函数创建对象

```js
//1. 通过调用系统的构造函数创建对象
	var obj = new Object();
// 2. 向对象中添加属性      对象.属性名 = 属性值
    obj.name = "孙悟空";
    obj.age = 18;
    obj.gender = "male";

// 3. 读取对象的属性      对象.属性名
	console.log(obj.name);

```

### 1.2.2 字面量的方式创建对象

> 以字面量的方式创建对象.
>
>   使用 { } 来创建一个空的对象, 和 new  Object() 本质上是一样. 

```js
	var obj = {};   // 字面量的方式创建一个 空对象
# 注意: 字面量方式创建的对象, 
# 各个名值对 中间用逗号 , 隔开, 最后一个名值对  后不再加 逗号 ,
	var obj2 = {
        name:"孙悟空",   // 注意名值对之间 用 逗号 , 隔开
        age: 18,
        gender:"male",

        friend: { // 给 obj2对象 的 friend 属性添加一个对象;
			name:"猪八戒";
        	age:500;
        	gender:"男";
        }
    }
	
// 比较两个对象是否相等时, 无论是相等还是全等,  比较的都是对象的内存地址.
     console.log(obj3 == obj4)   // 比较的是 obj3 和 obj4 对象的内存地址.
     console.log(obj3 === obj4)
```

### 1.2.3 以自定义构造函数的方式创建对象



## 1.3 对象中的属性名

### 1.3.1 对象中 设置属性的两种方式

> 1.    对象.属性名 = 属性值;
> 2. ​    对象["字符串值"] = 属性值;

```js
###1. 属性名
	属性名没有任何的要求，可以使任何内容.
        
1. 如果你使用属性名过于特殊，需要使用另一种方式来设置
	语法:  对象["属性名"]
	- 虽然可以随便起名, 但是如果没有特殊需要, 属性名应该尽量按照标识符的规范来书写.
 ----------------------------------------------------------   
###2. 对象中属性设置两种方式如下:
1. 对象中设置属性的两种方式
	对象.属性名 = 属性值;
	对象["字符串"] = 属性值;
	
	#注意:
    获取属性名的这两种方式本质没有什么特别, 但是中括号 [] 这种方式更加灵活.  它可以传入一个 字符串变量,比较灵活.  如:
    var a = "name";
	obj[a]  = "孙悟空";  //当 a 是不同的字符串时, 可以给对象设置不同的属性.所以说比较灵活.

2. 举个如下例子:
	var obj = new Object();
    obj.name = "孙悟空";
    obj.age = 18;
    obj["123123"] = "hello";   // 一般不这么特殊设置属性

    console.log(obj["123123"]); //特殊形式取属性名, 取出 hello

```

### 1.3.2 对象中获取属性的两种方式

> 1.    对象.属性名;
> 2.    对象["字符串"]; 

```js
###1. 获取属性名有两种方式
	1.   obj.name;   // 获取属性
	2.   obj["name"]   //  获取属性  (传入的是字符串)

	# 注意: 
    - 获取对象中的不存在的属性时, 不会报错, 而是会返回 undefined.
    
###2. 修改对象中的属性
	obj.name = "tom";

###3. 删除对象中的属性
// delete 属性可以删除对象中指定的属性.
	delete obj.name;

```

## 1.4 对象的属性值

```js
1. JS 中对象的属性值可以使任意的数据类型.
2. 可以使基本数据类型, 也可以是 对象, 数组.

举个例子如下:
		var obj = new Object();  
	 	obj.test = 123
        obj.test = true
        obj.test = null
        obj.test = undefined

        obj.test = new Object(); //给 obj的test属性赋值一个对象
        obj.test.name = '孙悟空'
        obj.test.age = 18
        // obj.test.obj = new Object() // 再给test对象的obj属性创建一个对象.
        console.log(obj.test.name)
        console.log(obj.test.age)

```

## 1.5 基本数据类型和引用数据类型

> 数据类型

```js
1. 基本数据类型
	String Boolean Number  Null Undefined
    - 基本数据类型的值与值之间都是相互独立的， 修改一个值，绝对不会影响到其他值
    - 基本数据类型是直接将值存储到了变量中

2. 引用数据类型
	Object
    - 应用数据类型, 变量不会去直接存储对象，而是存储的对象的内存地址（引用）
	- 当我们通过变量去操作对象时，实际上是通过内存地址找到了其对应的对象
然后再做相应的操作
    - 注意：
    如果两个变量指向的是同一个对象，通过一个变量修改对象时，
    在变量中也会有所体现（会影响到另一个 ）

```

## 1.6 对象属性的枚举(遍历)

> 对象属性的遍历通常用  for in 枚举遍历
>
> 语法:
>
> ​	for(var  变量  in  对象) {	
>
> ​		console.log(对象[变量]);  //  取出对象属性值
>
> ​	}
>
> for...in  循环会反复执行多次,  对象中有几个属性  就会执行几次.
>
> 每次执行都会将一个属性的名字赋值 给 变量 (即键值对中的 key 赋值给变量)

```js
// 1. 定义一个对象
	var stu = {
        name:'贾娇娇',
        age: 25,
        gender:"female"
    }

//2. 遍历该对象
	for(var keys  in stu) {
        console.log(stu[keys]);  // keys 变量存储了 stu对象的所有属性名, 所以可以 用  对象[keys]  的形式 遍历出 对象的属性值.
    }

```

## 1.7 in 运算符

> in 运算符
>
> 通过 in 这个运算符可以检查 对象中是否含有某个属性
>
> 如果对象中有 该属性, 则返回 true, 否则返回false
>
> 语法:    属性名   in  对象

```js
var obj = {
    name:"孙悟空", // 属性名是字符串,只不过通常我们写对象时没加引号.
    age:18,
}
console.log("name" in obj);   // 注意属性名 就是 字符串. 
console.log("address" in obj);

```

## 1.8 JS中函数定义的 3 种方式

> 1.  函数的声明 (函数的定义)
> 2. 函数表达式
> 3. 自调用函数

> 函数(function):
>
> 函数也是一个对象
>
> >  函数可以用来存储代码, 并且在需要时对这些代码进行调用
> >
> > 函数在 JS 中是 一等对象, 作用和 其他的对象一样
> >
> > 代码存储到函数中, 不会立即执行, 需要等到我们调用函数时, 函数中的代码才会执行.
> >
> > 调用函数方式:      函数对象();

### 1.8.1   函数声明方式定义函数(函数的定义)

```js
//1. 第一种: 函数声明方式定义函数(函数的定义)
	function 函数名() {
        函数体...
    }
-------------------------------------------        
  //例子:
   f1();   // 调用函数
   function f1() {
       console.log("函数声明的方式定义函数");
   }
-------------------------------------------
# 注意:
	console.log(f1); // 直接打印函数名, 打印出来代表的是函数体的代码.

```

## 1.8.2 函数表达式方式定义函数

> 语法:
>
> > var fn2 = function () {
> >
> > ​	函数体;
> >
> > }

```js
//这种方式定义的函数, 在fn2定义完之前调用会报错. fn2 is not a function
/*
  具体原因分析:
	通过 函数表达式的方式定义的函数, var fn2 的时候, 在 JS 里面变量声明的过程中,会有一个 变量  预解析的过程, 实际代码定义过程如下
	
	var fn2;
	
	fn2();  此时fn2调用时, fn2 = function() {} 这段代码还未执行, 因此 此时的 fn2 只是一个变量,不是 函数,所以会报 fn2 is not a function
	
	fn2 = function() {
		console.log("111");
	}
		
*/
-------------------------------------------------------
// fn2(); // 调用报错: fn2 is not a function
var fn2 = function() {
   console.log("我是函数表达式方式定义的函数...");        
}

fn2(); // 调用函数,注意此时是在函数定义完之后调用的
```

## 1.8.3  自调用函数 | 立即执行函数

>自调用函数通常会在 最前面加 一个  !   号,  防止自调用函数结构 和其他函数结构之间 因为没有分隔号而报错.

```js
// 自调用函数, 函数定义完成后立即执行,并且只会调用一次
    !(function() {
		console.log("hello");
    })();

```



## 1.9 函数的参数

```js
1. 定义函数时，可以在函数的() 中来指定数量不等的形参（形式参数）
2. 在函数中定义了形参就 相当于在函数中定义了几个变量但是并没有赋值

	function sum(a,b) {
        console.log(a + b);
    }
	sum(100,200);

3. 调用函数时, 可以在 () 中传递 实参 (实际参数)
	实参会对应赋值给 对应的 形参
    
实参的情况：
 如果实参的数量和形参一样，则对应的实参赋值给对应的形参
 如果实参的数量少于形参，没有对应实参的形参的值将会是undefined
 如果实参的数量多于形参，多余的实参将不会使用
 
#注意:
 函数调用，js解析器不会检查实参的类型，可以将任意的值作为实参使用
 所以调用函数时一定要小心！
```

## 1.10 函数返回值

```js
# 返回值
	- 返回值就是函数的执行结果，可以通过return关键字来设置函数的返回值
	- 语法:
    	return 值
	
	return 后的值将会成为函数的 返回值
    可以通过一个变量来接收 函数的返回值, 也可以直接打印 函数的返回值
    
    return 后边可以跟任意类型的值
	  可以是对象, 也可以是 一个函数.
    return 后边可以不跟任何值, 此时就相当于 return undefined
	如果函数不写 return, 也就相当于  return undefined.

# 返回值例子, 接收返回值
//1. 返回值例子一:
    function fn() {
        return 123;   // 函数执行返回 123
    }

	var result = fn();  // 调用fn函数, 通过 变量来接收函数返回值.
	console.log(result);
----------------------------------------------------------
//2. 返回值例子二:
	function fn2(a,b) {
    	return a + b;    
    }
	var sum = fn2(1,2);
	console.log(sum);
-------------------------------------------------------------
//3. 返回一个函数:  (使用闭包技术的时候会使用的非常多)
	function fn3() {
        return function() {
            console.log("我是内部的匿名函数...");
        }
    }

	var result = fn3();  // 此时返回的是一个函数, 用result接收了
	result();   // 此时再用result() 调用,可以调用函内返回的匿名函数
---------------------------------------------------------

//4. return 后可以不跟任何值.

```

## 1.11 return, break, 和 continue

```
1. 返回值就是函数的执行结果
	函数中return 一旦执行, 函数会立即结束, 也就是 return 后的代码全都不会执行.
	
2. break 一旦执行, 则直接终止循环代码. 之后的不再循环

3. continue 执行后会跳过当前循环, 直接进行下一次循环.

```

## 1.12  方法

> method (方法) 
>
> - 对象的属性值可以是任何类型, 也可以是对象, 甚至也可以使一个函数
> - 当对象的属性值是一个函数时, 我们称这个函数是 这个对象的方法, 调用这个函数,  我们就称是 调用这个对象的 xx 方法
>
> - 方法和函数没有本质的区别, 就是名字不同而已

```js
  var obj = {  // 字面量的方式创建一个对象.
        name:"孙悟空",
        sayHello:function() {  // sayHello 是 obj对象的方法
            console.log("大家好,我是孙悟空!!!");
        }
    }
    obj.sayHello();

```

## 1.13  作用域(scope)

> 1. 全局作用域
> 2. 函数作用域

> 作用域指的就是一个变量的作用范围
>
> 作用域分为两种
>
> 1. 全局作用域
>    - 全局作用域在网页加载时创建, 在网页关闭时销毁
>    - 所有的直接编写在 script 标签中的代码, 全都在全局作用域中
>    - 在全局作用域中创建的变量是全局变量, 可以在程序的任意位置被访问
>    - 在全局作用域中定义的函数是全局函数, 可以在任意的位置调用
>    - 在全局作用域中有一个全局对象 window, 该对象代表整个的浏览器窗口.
>    - 在全局作用域中创建的变量, 都会作为 window 对象的属性保存
>    - 在全局作用域中创建的函数, 多会作为 window 对象的方法保存.
>
> 2. 函数作用域: 

## 1.14 JS 中变量的预解析 (变量的提声)

>   JS中变量的预解析(提声):  表示 JS中的变量的 提前声明

```js
/**
  变量的预解析
	- 使用 var 声明的变量, 会在所有的代码执行前, 被创建, 但是不会赋值
	  赋值会在赋值语句执行时才会进行
	- 所以我们可以在变量声明前就使用变量.(前提是 使用 var 关键字声明)
	- 但是 不使用var 关键字声明的变量, 没有这个特点.
*/
	<script>
    	console.log(a);  // 这里打印 a 会报 undefined
		var a = 10; 
    </script>

```

## 1.15 JS 中函数的预解析 (函数的提声)

```js
<script>
    /**
     *  函数的提前声明
     *   1. 使用 函数声明 这种方式创建的函数, function fn() {}
     *      它会在所有的代码执行前执行. 函数声明会优先于所有代码将函数创建
     *      所以可以在函数声明前就调用函数, 如下调用 fn(); 函数
     *
     *   2. 而使用函数表达式方式创建的函数, 就没有这个特点.
     *      如下调用 fn2() 函数的时候,就会报  fn2 is not a function 错误
     */

//--------------------------------------------------------   
    
     /**
     *  实际这段代码会按照如下顺序执行
     *      1. fn函数  function fn() {} 这个函数实际会在所有代码执行前被加载,
     *          实际加载函数体是在 fn(); 函数调用前就加载了函数体,所以不会有错
     *
     *      2. fn2() 函数   var fn2 = function() {};
     *         - 会先把 var fn2 这个变量提声, 实际代码加载过程如下.
     *
     *         var fn2;
     *         fn2(); //此时调用fn2,只是一个变量,所以会报不是 function的错误
     *         
     *         fn2 = function() {};
     */
    fn();
    fn2(); // 报 fn2 is not a function 错误
    function fn() {
        console.log("hello, 我是 fn 函数")
    }
    var fn2  = function () {
        console.log(" hello, 我是 fn2 函数");
    }
</script>

```

# day12: 

## 1.1  函数作用域

>

```js



```

















 ​ 

















































































































































